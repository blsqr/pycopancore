
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pycopancore.private._expressions &#8212; pycopancore 0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pycopancore.private._expressions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Created on Mar 20, 2017.</span>

<span class="sd">@author: heitzig</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This file is part of pycopancore.</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2016-2017 by COPAN team at Potsdam Institute for Climate</span>
<span class="c1"># Impact Research</span>
<span class="c1">#</span>
<span class="c1"># URL: &lt;http://www.pik-potsdam.de/copan/software&gt;</span>
<span class="c1"># Contact: core@pik-potsdam.de</span>
<span class="c1"># License: BSD 2-clause license</span>

<span class="c1"># defines logics to deal with symbolic expressions and their evaluation</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">data_model</span> <span class="k">as</span> <span class="n">D</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">private</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">njit</span>


<span class="k">class</span> <span class="nc">_Unknown</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="n">unknown</span> <span class="o">=</span> <span class="n">_Unknown</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">_Unset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;unset&quot;</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="n">unset</span> <span class="o">=</span> <span class="n">_Unset</span><span class="p">()</span>


<span class="c1"># hierarchical aggregation functions:</span>

<span class="k">def</span> <span class="nf">aggregation</span><span class="p">(</span><span class="n">npfunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>

    <span class="c1"># TODO: add docstring to function</span>

    <span class="nd">@njit</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">lens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>

        <span class="c1"># TODO: add docstring to function</span>
        <span class="c1"># values = np.array(values)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lens</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">le</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lens</span><span class="p">):</span>
            <span class="n">newoffset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">le</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">npfunc</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">newoffset</span><span class="p">])</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">newoffset</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">func</span>

<span class="n">name2numpy</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">,</span>
    <span class="s2">&quot;any&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">,</span>
    <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
    <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
    <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">,</span>
    <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
    <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span>
    <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">aggregation_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">name2numpy</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">name2aggregation</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">aggregation</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">name2numpy</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="c1"># hierarchical broadcasting:</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">lens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>
    <span class="c1"># TODO: add docstring to function</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lens</span><span class="p">)))</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">le</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lens</span><span class="p">):</span>
        <span class="n">newoffset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">le</span>
        <span class="n">result</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">newoffset</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">newoffset</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">layout</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>
    <span class="c1"># TODO: add docstring to function</span>
    <span class="k">for</span> <span class="n">lens</span> <span class="ow">in</span> <span class="n">layout</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">lens</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span>


<span class="k">def</span> <span class="nf">layout2lens</span><span class="p">(</span><span class="n">layout</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>
    <span class="c1"># TODO: add docstring to function</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">layout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">lens</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">layout</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newresult</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">le</span> <span class="ow">in</span> <span class="n">lens</span><span class="p">:</span>
            <span class="n">newoffset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">le</span>
            <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">newoffset</span><span class="p">]))</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">newoffset</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">newresult</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">get_cardinalities_and_branchings</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring&quot;&quot;&quot;</span>
    <span class="c1"># TODO: add docstring to function</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">cardinalities</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">branchings</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="c1"># use longest cardinalities of args:</span>
        <span class="n">cbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_cardinalities_and_branchings</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cbs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">cbs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cbs</span><span class="p">])]</span>


<span class="k">class</span> <span class="nc">_DotConstruct</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">AtomicExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A _DotConstruct represents a syntactical construct with dots,</span>
<span class="sd">    starting with an entity-type or process taxon class,</span>
<span class="sd">    followed by zero or more ReferenceVariables or SetVariables</span>
<span class="sd">    or aggregation keywords such as sum, and ending in either an attribute,</span>
<span class="sd">    e.g. SocialSystem.sum.cells.population</span>
<span class="sd">    or an aggregation keyword without evaluation,</span>
<span class="sd">    e.g. SocialSystem.world.sum,</span>
<span class="sd">    or an aggregation keyword with evaluation,</span>
<span class="sd">    e.g. SocialSystem.world.sum(some expression).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_start</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;the entity-type, process taxon, ReferenceVariable or SetVariable </span>
<span class="sd">    at the start of the dot construct, e.g. SocialSystem or Environment.cells&quot;&quot;&quot;</span>
    <span class="n">_attribute_sequence</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;the sequence of further names, which must be codenames of variables,</span>
<span class="sd">    e.g. [&quot;cells&quot;,&quot;population&quot;]&quot;&quot;&quot;</span>
    <span class="n">_aggregation</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;the optional name of an aggregation function </span>
<span class="sd">    at the end of the construct, e.g., &quot;sum&quot;.&quot;&quot;&quot;</span>
    <span class="n">_argument</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;the optional argument expression of the aggregation function, e.g.</span>
<span class="sd">    SocialSystem.world.sum.cells.population * SocialSystem.world.sum.cells.capital&quot;&quot;&quot;</span>
    <span class="n">_can_be_target</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;whether this can be a target (i.e., does not involve aggregation)&quot;&quot;&quot;</span>

    <span class="n">_initialized</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;whether it was initialized already&quot;&quot;&quot;</span>

    <span class="c1"># needed to make sympy happy:</span>
    <span class="n">_argset</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">is_Add</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_float</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1">#    is_symbol = True</span>
<span class="c1">#    is_Symbol = True</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">printing</span><span class="o">.</span><span class="n">precedence</span><span class="o">.</span><span class="n">PRECEDENCE</span><span class="p">[</span><span class="s2">&quot;Atom&quot;</span><span class="p">]</span>
    <span class="n">_iterable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># needed to make sphinx happy:</span>
    <span class="vm">__qualname__</span> <span class="o">=</span> <span class="s2">&quot;pycopancore.private._expressions._DotConstruct&quot;</span>


    <span class="c1"># inheritance from Symbol is a little tricky since Symbol has a custom</span>
    <span class="c1"># __new__ method that returns the same object everytime the name is the</span>
    <span class="c1"># same! We break this behaviour by using random Symbol.names so that we</span>
    <span class="c1"># can multiple copies of a Variable having the same name, to be attached</span>
    <span class="c1"># to different entity types:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                <span class="n">start</span><span class="p">,</span>
                <span class="n">attribute_sequence</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="n">aggregation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">argument</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>

        <span class="n">uid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>  <span class="c1"># repr</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">uid</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attribute_sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aggregation</span><span class="p">:</span>
            <span class="n">uid</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">aggregation</span>
            <span class="k">if</span> <span class="n">argument</span><span class="p">:</span>
                <span class="n">uid</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>  <span class="c1"># repr</span>
<span class="c1">#        print(&quot;_DotConstruct.__new__ with uid&quot;, uid)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">start</span><span class="p">,</span>
                 <span class="n">attribute_sequence</span><span class="p">,</span>
                 <span class="n">aggregation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">argument</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span> <span class="o">=</span> <span class="n">attribute_sequence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span> <span class="o">=</span> <span class="n">aggregation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_argument</span> <span class="o">=</span> <span class="n">argument</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span> <span class="o">=</span> <span class="p">(</span><span class="n">aggregation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_target_class</span> <span class="o">=</span> <span class="n">unknown</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_variable</span> <span class="o">=</span> <span class="n">unknown</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span> <span class="o">=</span> <span class="n">unknown</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_branchings</span> <span class="o">=</span> <span class="n">unknown</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cardinalities</span> <span class="o">=</span> <span class="n">unknown</span>

<span class="c1">#            print(&quot;_DotConstruct.__init__ of&quot;,self,&quot;performed&quot;)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="c1">#            print(&quot;repeated _DotConstruct.__init__ of&quot;,self,&quot;skipped&quot;)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;accessing an attribute of a _DotConstruct basically</span>
<span class="sd">        returns a new _DotConstruct that is extended by the name of this</span>
<span class="sd">        attribute, giving special treatment to aggregations&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">:</span>  <span class="c1"># needed to make sphinx happy</span>
            <span class="k">return</span> <span class="s2">&quot;DUMMY&quot;</span>  <span class="c1"># FIXME!</span>
<span class="c1">#        print(&quot;_DotConstruct.__getattr__(&quot;, self, &quot;,&quot;, name, &quot;)&quot;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># we are an aggregation with argument</span>
            <span class="c1"># append name to argument:</span>
<span class="c1">#            print(&quot;extending argument&quot;,self._argument,&quot;by&quot;,name)</span>
            <span class="n">newarg</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">newdc</span> <span class="o">=</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">,</span>
                                  <span class="n">aggregation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">,</span>
                                  <span class="n">argument</span><span class="o">=</span><span class="n">newarg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">:</span>  <span class="c1"># we are an aggregation without argument yet</span>
            <span class="c1"># add an argument:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">])</span>
<span class="c1">#            print(&quot;adding argument&quot;,argument,&quot;to aggregation of type&quot;,self._aggregation)</span>
            <span class="n">newdc</span> <span class="o">=</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">,</span>
                                  <span class="n">aggregation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">,</span>
                                  <span class="n">argument</span><span class="o">=</span><span class="n">argument</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">aggregation_names</span><span class="p">:</span>  <span class="c1"># we become an aggregation</span>
<span class="c1">#            print(&quot;adding aggregation of type&quot;,name)</span>
            <span class="n">newdc</span> <span class="o">=</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">,</span>
                                  <span class="n">aggregation</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># append name to attribute_sequence:</span>
<span class="c1">#            print(&quot;adding variable reference named&quot;,name)</span>
            <span class="n">newdc</span> <span class="o">=</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span> <span class="o">+</span> <span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">newdc</span>
        <span class="c1"># Note that this causes hasattr(...) to always return True!</span>
        <span class="c1"># Hoping this causes no problem...</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calling is only allowed if we are an aggregation without argument yet,</span>
<span class="sd">        and results in adding an argument&quot;&quot;&quot;</span>
        <span class="c1"># TODO: reactivate the following line after fixing sphinx bug:</span>
<span class="c1">#        assert self._aggregation and not self._argument, &quot;can&#39;t have brackets here&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;must have exactly one argument&quot;</span>
        <span class="k">return</span> <span class="n">_DotConstruct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">,</span>
                             <span class="n">aggregation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">,</span>
                             <span class="n">argument</span><span class="o">=</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># TODO: understand why an earlier version had this:</span>
<span class="c1">#        else:</span>
<span class="c1">#            return sp.AtomicExpr()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1">#        return self.__repr__()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="c1"># needed to make sympy happy: (may need further later)</span>
    <span class="k">def</span> <span class="nf">_sympystr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_eval_expand_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_eval_Eq</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="c1"># this does not work unfortunately:</span>
<span class="c1">#    def __eq__(self, other):</span>
<span class="c1">#        print(&quot;eq?&quot;)</span>
<span class="c1">#        if self._target_instances is unknown:</span>
<span class="c1">#            print(&quot;std.&quot;)</span>
<span class="c1">#            return sp.AtomicExpr.__eq__(self, other)</span>
<span class="c1">#        else:</span>
<span class="c1">#            print(&quot;Eq&quot;)</span>
<span class="c1">#            return sp.Eq(self, other)</span>
<span class="c1"># so A == B cannot be used in formulas, instead sp.Eq(A,B) must be used.</span>

    <span class="c1"># TODO: put a leading underscore before as many method names as possible</span>
    <span class="c1"># (only not those needed by sympy), to avoid name clashes with variables</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">owning_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the class owning the _DotConstruct&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">owning_class</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">_composed_class</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">_composed_class</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">target_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the class owning the target attribute&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_class</span> <span class="ow">is</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">ReferenceVariable</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">SetVariable</span><span class="p">)):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">type</span>  <span class="c1"># referred entity type/taxon</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">ReferenceVariable</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">SetVariable</span><span class="p">))</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_class</span> <span class="o">=</span> <span class="bp">cls</span>
<span class="c1">#            print(&quot;finding target class of&quot;,self,&quot;as&quot;,cls)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_class</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">target_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the Variable object representing the target attribute&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_variable</span> <span class="ow">is</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_target_variable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_class</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">#            print(&quot;getting target variable of&quot;,self,&quot;as&quot;,self._target_variable)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_variable</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">target_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the list of instances owning the referenced attributes,</span>
<span class="sd">        may contain instances more than once due to broadcasting&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span> <span class="ow">is</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyse_instances</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">branchings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the list of branching lens at SetReferences,</span>
<span class="sd">        to be used in aggregation and broadcasting&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span> <span class="ow">is</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyse_instances</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_branchings</span>

    <span class="nd">@property</span>  <span class="c1"># read-only</span>
    <span class="k">def</span> <span class="nf">cardinalities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the list of level cardinalities at SetReferences,</span>
<span class="sd">        to be used in aggregation and broadcasting&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span> <span class="ow">is</span> <span class="n">unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_analyse_instances</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardinalities</span>

    <span class="k">def</span> <span class="nf">_analyse_instances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(&quot;      (analysing instance structure of&quot;,self,&quot;)&quot;)</span>
        <span class="n">oc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owning_class</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">oc</span><span class="o">.</span><span class="n">instances</span>
        <span class="n">branchings</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)]]</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)]</span>  <span class="c1"># store initial cardinality</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">codename</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># each item is a set of instances:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">branchings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_set</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instance_set</span><span class="p">]</span>
                <span class="c1"># store cardinality after the branching:</span>
                <span class="n">cardinalities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
                <span class="c1"># items may now be a list of instances or a list of sets of</span>
                <span class="c1"># instances...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">branchings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_set</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span>
                     <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instance_set</span><span class="p">]</span>
            <span class="c1"># store cardinality after the branching:</span>
            <span class="n">cardinalities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_instances</span> <span class="o">=</span> <span class="n">items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_branchings</span> <span class="o">=</span> <span class="n">branchings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cardinalities</span> <span class="o">=</span> <span class="n">cardinalities</span>

    <span class="c1"># TODO add a method that differentiates symbolically w.r.t. some variable?</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets referenced attribute values and performs aggregations</span>
<span class="sd">        where necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        print(&quot;eval&quot;,self)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">owning_class</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">instances</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">instances</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">codename</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instance_set</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argument</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;aggregation without argument&quot;</span>
            <span class="c1"># make sure items is list of instances not list of sets:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span>
                         <span class="k">for</span> <span class="n">instance_set</span> <span class="ow">in</span> <span class="n">items</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instance_set</span><span class="p">]</span>
            <span class="c1"># sic! (not items!):</span>
            <span class="n">arg_values</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">,</span> <span class="n">instances</span><span class="p">)</span>
            <span class="n">cardinalities</span><span class="p">,</span> <span class="n">branchings</span> <span class="o">=</span> \
                <span class="n">get_cardinalities_and_branchings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argument</span><span class="p">)</span>
            <span class="n">aggregation_level</span> <span class="o">=</span> <span class="n">cardinalities</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
            <span class="n">layout</span> <span class="o">=</span> <span class="n">branchings</span><span class="p">[</span><span class="n">aggregation_level</span><span class="p">:]</span> \
                <span class="k">if</span> <span class="n">aggregation_level</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cardinalities</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> \
                <span class="k">else</span> <span class="p">[[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]]</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="n">layout2lens</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">name2aggregation</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregation</span><span class="p">](</span><span class="n">arg_values</span><span class="p">,</span> <span class="n">lens</span><span class="p">)</span> \
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lens</span><span class="p">]</span>
<span class="c1">#            print(&quot;aggregation&quot;,self,items)</span>
        <span class="k">return</span> <span class="n">items</span>

    <span class="k">def</span> <span class="nf">_broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;broadcast a list of values from entities at an intermediate level</span>
<span class="sd">        to their &quot;offspring&quot; entities at the final level&quot;&quot;&quot;</span>
        <span class="n">value_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinalities</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">value_level</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cardinalities</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branchings</span><span class="p">[</span><span class="n">value_level</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">add_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;adds summands to referenced attribute values&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="c1"># broadcast values if necessary:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_instances</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">add_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;adds summands to referenced attribute values&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="c1"># broadcast values if necessary:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">dname</span> <span class="o">=</span> <span class="s2">&quot;d_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_instances</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dname</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dname</span><span class="p">)</span> <span class="o">+</span> <span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">fast_set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;store values without further checks&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">,</span> <span class="s2">&quot;cannot serve as target&quot;</span>
        <span class="c1"># broadcast values if necessary:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attribute_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_instances</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>

<span class="c1">#    def __iter__(self):</span>
<span class="c1">#        print(&quot;AHA!&quot;)</span>
<span class="c1">#        yield self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_power_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="n">func2numpy</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># unary:</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Abs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">acos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">acosh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">asin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">asinh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">atan</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">atan2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">atanh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">ceiling</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">cosh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">erf</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erf</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">erfc</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfc</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">erfinv</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfinv</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">erfcinv</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">erfcinv</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">floor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Heaviside</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">sinh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">tan</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">tanh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span>
    <span class="c1"># n-ary:</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Max</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Min</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">binary2numpy</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Ge</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Gt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Le</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Lt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Ne</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">nary2numpy</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">And</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Mul</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Or</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Xor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_cached_values</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_cached_iteration</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">have_warned</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># TODO: use a separate cache for expressions that do not change during ode</span>
<span class="c1"># integration and devaluate it only between integration intervals.</span>
<span class="c1"># TODO: also use sympy to simplify and maybe even solve systems of equations</span>
<span class="k">def</span> <span class="nf">_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">global</span> <span class="n">_cached_iteration</span><span class="p">,</span> <span class="n">_cached_values</span>
        <span class="k">if</span> <span class="n">_cached_iteration</span> <span class="o">==</span> <span class="n">iteration</span><span class="p">:</span>
            <span class="c1"># still up to date, so try returning vals from cache:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">_cached_values</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
<span class="c1">#                print(&quot;read from cache:&quot;,expr)</span>
                <span class="k">return</span> <span class="n">res</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># clear cache:</span>
            <span class="n">_cached_values</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">_cached_iteration</span> <span class="o">=</span> <span class="n">iteration</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">FunctionClass</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="n">argvals</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">argcards</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">argbrs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">argvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">argcards</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">argbrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">_eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">)</span>
        <span class="c1"># TODO: broadcast shorter args to level of longest arg!</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">argcards</span><span class="p">])</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="n">argcards</span><span class="p">[</span><span class="n">longest</span><span class="p">]</span>
        <span class="n">branchings</span> <span class="o">=</span> <span class="n">argbrs</span><span class="p">[</span><span class="n">longest</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">longest</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">cardinalities</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
                <span class="n">argvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">argvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">branchings</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">_DotConstruct</span><span class="p">):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">eval</span><span class="p">())</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">cardinalities</span>
        <span class="n">branchings</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">branchings</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Not</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">argvals</span><span class="p">)</span>
    <span class="c1"># binary operators:</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">binary2numpy</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">binary2numpy</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">argvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># ternary operators:</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">ITE</span><span class="p">:</span>
        <span class="n">truthvals</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">trues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">truthvals</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># &quot;==&quot; is correct here, since it may be a sympy.True!! Do not replace &quot;==&quot; by &quot;is&quot;!!</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">vals</span><span class="p">[</span><span class="n">trues</span><span class="p">]</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">trues</span><span class="p">]</span>
    <span class="c1"># n-ary operators:</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">nary2numpy</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">nary2numpy</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="n">argvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Following: = True if even no. of arguments is True = Not(Xor):</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Equivalent</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">argvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Nand</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">argvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Nor</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">argvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">argvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># FIXME: do the following much better!</span>
<span class="c1">#        EPS = 1e-10</span>
<span class="c1">#        LARGE = 1e50</span>
<span class="c1">#        base[np.where(np.isnan(base))] = 0</span>
<span class="c1">#        # try to avoid overflows due to (small abs)**(negative):</span>
<span class="c1">#        base[np.where(np.logical_and(np.abs(base) &lt; EPS, exponent &lt; 0))] = EPS</span>
<span class="c1">#        # try to avoid overflows due to (large abs)**(positive):</span>
<span class="c1">#        base[np.where(np.logical_and(</span>
<span class="c1">#             np.abs(base) &gt; LARGE, exponent &gt; 0))] = LARGE</span>
<span class="c1">#        # try to avoid invalid values due to (negative)**(non-integer):</span>
<span class="c1">#        base[np.where(np.logical_and(base &lt; 0, exponent % 1 != 0))] = EPS</span>
<span class="c1">#        print(base[:10],exponent[:10])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">pass</span>
<span class="c1">#            base[np.where((base == 0)*(exponent &lt; 0))] = 1e-10</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;oops! couldn&#39;t set values&quot;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">base</span> <span class="o">**</span> <span class="n">exponent</span>
        <span class="n">isn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isn</span><span class="p">):</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isn</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">global</span> <span class="n">have_warned</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">have_warned</span><span class="p">:</span>
                <span class="n">have_warned</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: invalid value encountered in power</span><span class="se">\n</span><span class="s2">base:&quot;</span><span class="p">,</span>
                      <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">[</span><span class="n">wh</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">exponent:&quot;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">exponent</span><span class="p">[</span><span class="n">wh</span><span class="p">])</span>
            <span class="n">vals</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># TODO: is this a good idea?</span>
    <span class="c1"># TODO: other types of expressions, including function evaluations!</span>
    <span class="c1"># other functions/unary operators:</span>
    <span class="k">elif</span> <span class="n">tt</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="n">FunctionClass</span><span class="p">:</span>
        <span class="c1"># it is a sympy function</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">func2numpy</span><span class="p">[</span><span class="n">t</span><span class="p">](</span><span class="o">*</span><span class="n">argvals</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># simple scalar for broadcasting:</span>
        <span class="c1"># clumsy way of converting sympy True to normal True:</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span>
        <span class="n">cardinalities</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">branchings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># store vals in cache:</span>
        <span class="n">_cached_values</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">cardinalities</span><span class="p">,</span> <span class="n">branchings</span><span class="p">)</span>
<span class="c1">#        print(&quot;stored in cache:&quot;,expr)</span>
    <span class="k">return</span> <span class="n">vals</span><span class="p">,</span> <span class="n">cardinalities</span><span class="p">,</span> <span class="n">branchings</span>


<span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dummy docstring - wrap private _eval function?&quot;&quot;&quot;</span>
    <span class="c1"># TODO: add docstring to function</span>
    <span class="n">vals</span><span class="p">,</span> <span class="n">cardinalities</span><span class="p">,</span> <span class="n">branchings</span> <span class="o">=</span> <span class="n">_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vals</span>


<span class="k">def</span> <span class="nf">get_vars</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;find all variables occurring in Expression&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">_DotConstruct</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">_can_be_target</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="n">expr</span><span class="o">.</span><span class="n">target_variable</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">get_vars</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_argument</span><span class="p">)</span>
    <span class="n">varset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="n">varset</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_vars</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">varset</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference.html#pycopancore">pycopancore</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials by role</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../step_by_step.html">Step by step tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../framework_documentation/index.html">Framework documentation</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, the copan team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>